#import <Cocoa/Cocoa.h>

enum TOKEN_MATCH_TYPE { TOKEN_NONE, TOKEN_COMMENT, TOKEN_SETUP, TOKEN_BASE, TOKEN_IMPORT, TOKEN_STATIC, TOKEN_NAME, TOKEN_PASTE, TOKEN_CODE } tokenMatch;

int main (int argc, const char * argv[]) {
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    if (argc != 3) {
        puts("BXML Parser version 2.0.0 -- (c) 2010 Bombaxtic LLC");
        puts("Usage:  bxmlparser SOURCE.bxml OUTPUT.m");
        return 1;
    }
    NSString *bxmlPath = [NSString stringWithUTF8String:argv[1]];
    NSString *outputPath = [NSString stringWithUTF8String:argv[2]];
    NSString *bxmlName = [[[bxmlPath lastPathComponent] stringByDeletingPathExtension] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]]; 
    
    NSCharacterSet *identifierChars = [NSCharacterSet characterSetWithCharactersInString:@"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"];
    NSCharacterSet *identifierStartChars = [NSCharacterSet characterSetWithCharactersInString:@"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"];
    NSMutableString *handlerName = [NSMutableString stringWithCapacity:[bxmlName length]];

    NSString *underScore = @"_";
    NSString *unicharFormat = @"%C";
    for (int i = 0; i < [bxmlName length]; i++) {
        unichar c = [bxmlName characterAtIndex:i];
        if (i == 0) {
            if ([identifierStartChars characterIsMember:c]) {
                [handlerName appendFormat:unicharFormat, c];
            } else {
                [handlerName appendString:underScore];
            }
        } else {
            if ([identifierChars characterIsMember:c]) {
                [handlerName appendFormat:unicharFormat, c];
            } else {
                [handlerName appendString:underScore];
            }
        }
    }
//    if ([handlerName length] == 0) {
//        puts("After converting characters, the resulting handler's name is empty.");
//        return 2;
//    } else if (! [handlerName isEqualToString:bxmlName]) {
//        printf("INFO: The BXML name '%s' was renamed to '%s'.\n", [bxmlName UTF8String], [handlerName UTF8String]);
//    }
    
    NSError *error = nil;
    NSString *bxml = [NSString stringWithContentsOfFile:bxmlPath
                                               encoding:NSUTF8StringEncoding
                                                  error:&error];
    if (error != nil) {
        printf("Error, BXML file '%s' not found.\n", argv[1]);
        return 2;
    }

    NSMutableArray *importList = [NSMutableArray arrayWithCapacity:4];
    [importList addObject:@"<Cocoa/Cocoa.h>"];
    [importList addObject:@"<Bombaxtic/Bombaxtic.h>"];
    
    NSMutableString *baseClass = [NSMutableString stringWithCapacity:64];
    [baseClass setString:@"BxHandler"];

    NSMutableString *setupCode = [NSMutableString stringWithCapacity:0];

    NSMutableString *renderCode = [NSMutableString stringWithCapacity:4096];
    [renderCode appendString:@"[super renderWithTransport:_];\n"];

    // bxml-path, imports, handler-name, base-class, handler-name, setup-code, render-code */
    NSString *sourceTemplate = @"/* DO NOT MODIFY. AUTOGENERATED FROM %@ */\n\n%@\n\n@interface %@ : %@ {\n\n}\n\n@end\n\n@implementation %@\n\n- (id)setup {\n    [super setup];\n%@;\n    return self;\n}\n\n- (id)renderWithTransport:(BxTransport *)_ {\n%@;\n    return self;\n}\n\n@end\n\n";

    NSString *tokenComment = @"<?--";
    NSString *tokenSetup = @"<?setup";
    NSString *tokenBase = @"<?base";
    NSString *tokenImport = @"<?import";
    NSString *tokenStatic = @"<?static";
    NSString *tokenName = @"<?name";
    NSString *tokenPaste = @"<?paste";
    NSString *tokenCode = @"<?";
    NSString *tokenEndComment = @"--?>";
    NSString *tokenEndOther = @"?>";
    
    int start = 0;
    while (start < [bxml length]) {
        int remainder = [bxml length] - start;
        NSRange searchRange = NSMakeRange(start, remainder);
        NSUInteger commentStart = [bxml rangeOfString:tokenComment options:0 range:searchRange].location;
        NSUInteger setupStart = [bxml rangeOfString:tokenSetup options:0 range:searchRange].location;
        NSUInteger baseStart = [bxml rangeOfString:tokenBase options:0 range:searchRange].location;
        NSUInteger nameStart = [bxml rangeOfString:tokenName options:0 range:searchRange].location;
        NSUInteger importStart = [bxml rangeOfString:tokenImport options:0 range:searchRange].location;
        NSUInteger staticStart = [bxml rangeOfString:tokenStatic options:0 range:searchRange].location;
        NSUInteger pasteStart = [bxml rangeOfString:tokenPaste options:0 range:searchRange].location;
        NSUInteger codeStart = [bxml rangeOfString:tokenCode options:0 range:searchRange].location;
        tokenMatch = TOKEN_NONE;
        if (codeStart != NSNotFound) {
            remainder = codeStart;
            tokenMatch = TOKEN_CODE;
        }
        if (commentStart != NSNotFound && codeStart <= remainder) {
            remainder = commentStart;
            tokenMatch = TOKEN_COMMENT;
        }
        if (setupStart != NSNotFound && setupStart <= remainder) {
            remainder = setupStart;
            tokenMatch = TOKEN_SETUP;
        }
        if (baseStart != NSNotFound && baseStart <= remainder) {
            remainder = baseStart;
            tokenMatch = TOKEN_BASE;
        }
        if (nameStart != NSNotFound && nameStart <= remainder) {
            remainder = nameStart;
            tokenMatch = TOKEN_NAME;
        }
        if (importStart != NSNotFound && importStart <= remainder) {
            remainder = importStart;
            tokenMatch = TOKEN_IMPORT;
        }
        if (staticStart != NSNotFound && staticStart <= remainder) {
            remainder = staticStart;
            tokenMatch = TOKEN_STATIC;
        }
        if (pasteStart != NSNotFound && pasteStart <= remainder) {
            remainder = pasteStart;
            tokenMatch = TOKEN_PASTE;
        }
        if (tokenMatch == TOKEN_NONE) {
            remainder = [bxml length];
        }
        NSMutableString *outText = [[bxml substringWithRange:NSMakeRange(start, remainder - start)] mutableCopy];
        if ([outText length] > 0) {
            [outText replaceOccurrencesOfString:@"\\"
                                     withString:@"\\\\"
                                        options:0
                                          range:NSMakeRange(0, [outText length])];
            [outText replaceOccurrencesOfString:@"\""
                                     withString:@"\\\""
                                        options:0
                                          range:NSMakeRange(0, [outText length])];
            [outText replaceOccurrencesOfString:@"\n"
                                     withString:@"\\n"
                                        options:0
                                          range:NSMakeRange(0, [outText length])];
            [outText replaceOccurrencesOfString:@"\t"
                                     withString:@"\\t"
                                        options:0
                                          range:NSMakeRange(0, [outText length])];
            [outText replaceOccurrencesOfString:@"\r"
                                     withString:@"\\r"
                                        options:0
                                          range:NSMakeRange(0, [outText length])];
            // other replacement? escape hex characters? -- we could just go through each one...
            // xxx we need to internationalize this
            [renderCode appendFormat:@"    [_ write:@\"%@\"];\n", outText];
        }
        int offset = remainder;
        remainder = [bxml length] - offset;
        searchRange = NSMakeRange(offset, remainder);
        if (tokenMatch == TOKEN_COMMENT) {
            NSUInteger commentEnd = [bxml rangeOfString:tokenEndComment options:0 range:searchRange].location;
            if (commentEnd == NSNotFound) {
                break;
            } else {
                start = commentEnd + [tokenEndComment length];
            }
        } else if (tokenMatch != TOKEN_NONE) {
            NSUInteger otherEnd = [bxml rangeOfString:tokenEndOther options:0 range:searchRange].location;
            if (otherEnd == NSNotFound) {
                otherEnd = [bxml length];
            }
            NSMutableString *mstr;
            NSString *str;
            switch (tokenMatch) {
                case TOKEN_BASE:
                    offset += [tokenBase length];
                    [baseClass setString:[[bxml substringWithRange:NSMakeRange(offset,  otherEnd - offset)] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]]];
                    break;
                case TOKEN_SETUP:
                    offset += [tokenSetup length]; 
                    [setupCode appendFormat:@"%@;\n", [bxml substringWithRange:NSMakeRange(offset, otherEnd - offset)]];
                    break;
                case TOKEN_NAME:
                    offset += [tokenName length];
                    [handlerName setString:[[bxml substringWithRange:NSMakeRange(offset,  otherEnd - offset)] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]]];
                    break;
                case TOKEN_IMPORT:
                    offset += [tokenImport length]; 
                    mstr = [[[bxml substringWithRange:NSMakeRange(offset, otherEnd - offset)] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]] mutableCopy];
                    if ([mstr characterAtIndex:0] == '"' || [mstr characterAtIndex:0] == '<') {
                        [importList addObject:mstr];
                    } else {
                        [mstr insertString:@"\"" atIndex:0];
                        [mstr appendString:@"\""];
                        [importList addObject:mstr];
                    }
                    break;          
                case TOKEN_STATIC:
                    offset += [tokenStatic length];
                    str = [[bxml substringWithRange:NSMakeRange(offset, otherEnd - offset)] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
                    [renderCode appendFormat:@"\n    [_ write:[_app staticWebPath:@\"%@\"]];\n", str];
                    break;
                case TOKEN_PASTE:
                    offset += [tokenPaste length];
                    str = [[bxml substringWithRange:NSMakeRange(offset, otherEnd - offset)] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
                    [renderCode appendFormat:@"\n    [[_app handlerInstanceForClassName:@\"%@\"] renderWithTransport:_];\n", str];
                    break;
                case TOKEN_CODE:
                    offset += [tokenCode length];
                    [renderCode appendFormat:@"    %@;\n", [bxml substringWithRange:NSMakeRange(offset, otherEnd - offset)]];
                    break;          
                default:
                    break;
            }
            start = otherEnd + [tokenEndOther length];
        } else {
            break;
        }
    }
    
    NSMutableString *importCode = [NSMutableString stringWithCapacity:[importList count] * 24];

    NSString *baseClassHeader = nil;
    if (! [baseClass isEqualToString:@"BxHandler"]) {
        baseClassHeader = [NSString stringWithFormat:@"%@.h\"", baseClass];
    }
    BOOL foundBaseClass = NO;
    for (NSString *importFile in importList) {
        [importCode appendFormat:@"#import %@\n", importFile];
        if (baseClassHeader && [importFile hasSuffix:baseClassHeader]) {
            foundBaseClass = YES;
        }
    }
    if (baseClassHeader && ! foundBaseClass) {
        [importCode appendFormat:@"#import \"%@\n", baseClassHeader];
    }
    NSString *output = [NSString stringWithFormat:sourceTemplate, bxmlPath, importCode, handlerName, baseClass, handlerName, setupCode, renderCode];
    error = nil;
    [output writeToFile:outputPath
             atomically:NO
               encoding:NSUTF8StringEncoding
                  error:&error];
    if (error != nil) {
        printf("There was an error while generating the objective-c handler from the BXML: %s\n", [[error localizedDescription] UTF8String]);
        return 3;
    }    
    [pool release];
    return 0;
}
