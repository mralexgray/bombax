<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Bombaxtic Framework: BxDatabaseConnection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>BxDatabaseConnection Class Reference</h1><!-- doxytag: class="BxDatabaseConnection" -->
<p>Connects to and communicates with a database.  
<a href="#_details">More...</a></p>

<p><a href="class_bx_database_connection-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#aaf52b3d6472872841651409abf7e7dda">beginTransaction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begins a database transaction.  <a href="#aaf52b3d6472872841651409abf7e7dda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#a1388401ae0c42963f74e07baa9ab43f7">close</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes the database connection.  <a href="#a1388401ae0c42963f74e07baa9ab43f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#a346e964e3aa16d346b293ecfb9758349">commitTransaction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commits an existing database transaction.  <a href="#a346e964e3aa16d346b293ecfb9758349"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#a4d69e6d8dfa362c31cbc5a42c8f1be74">execute:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the provided SQL.  <a href="#a4d69e6d8dfa362c31cbc5a42c8f1be74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#aa6eef02d9c33c3ef79b71e4fa477cedb">executeWith:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the provided SQL with the provided values.  <a href="#aa6eef02d9c33c3ef79b71e4fa477cedb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#a94a1a9843080a3f7ebc9246faf0efd10">fetchAll:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an array of row arrays for a SELECT statement.  <a href="#a94a1a9843080a3f7ebc9246faf0efd10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#ab9602263d3bb8d1d4086aae886f415f0">fetchAllWith:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an array of row arrays for a SELECT statement with the provided values.  <a href="#ab9602263d3bb8d1d4086aae886f415f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#ad14105b6c66984fc921e7e0e91091445">fetchNamedAll:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an array of row dictionaries for a SELECT statement.  <a href="#ad14105b6c66984fc921e7e0e91091445"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#a16b51c5cb344618db822617093741c4c">fetchNamedAllWith:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an array of row dictionaries for a SELECT statement with the provided values.  <a href="#a16b51c5cb344618db822617093741c4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSDictionary *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#aa3302ac78f09ea09a51cda69e4815fb4">fetchNamedRow:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a single of row dictionary for a SELECT statement.  <a href="#aa3302ac78f09ea09a51cda69e4815fb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSDictionary *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#a84ffce45f9f416453bd14e0f09f3e43c">fetchNamedRowWith:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a single of row dictionary for a SELECT statement with the provided values.  <a href="#a84ffce45f9f416453bd14e0f09f3e43c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#aee6c7a159f66e0df2991c1ee7ce20843">fetchRow:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a single of row array for a SELECT statement.  <a href="#aee6c7a159f66e0df2991c1ee7ce20843"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#a3a9136ffa1139c6ad6eff9d72416389a">fetchRowWith:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a single of row array for a SELECT statement with the provided values.  <a href="#a3a9136ffa1139c6ad6eff9d72416389a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#a1d9141ac450a15a4a9ed464b959c3bb8">initWithMySQLServer:database:user:password:locking:error:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> for a MySQL server.  <a href="#a1d9141ac450a15a4a9ed464b959c3bb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#ae7a2b46cc77af4f7c0c89a9050bd159f">initWithMySQLServer:database:user:password:port:socket:locking:error:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> for a MySQL server.  <a href="#ae7a2b46cc77af4f7c0c89a9050bd159f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#af22026065b4005c973d2a4f5c0f9ab3b">initWithOracleInstance:user:password:locking:error:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> to an Oracle server.  <a href="#af22026065b4005c973d2a4f5c0f9ab3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#af979486a5816070db16c1697706414b3">initWithPostgreSQLServer:database:user:password:port:locking:error:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> for a PostgreSQL server.  <a href="#af979486a5816070db16c1697706414b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#a1092698d2ba1929ce99f3bfa2f69248e">initWithSQLiteFile:locking:error:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> for a SQLite file.  <a href="#a1092698d2ba1929ce99f3bfa2f69248e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#a9b91b0183da97c3ce5d303af22996c6b">initWithSQLiteMemoryWithLocking:error:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> for an in-memory SQLite database.  <a href="#a9b91b0183da97c3ce5d303af22996c6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_bx_database_statement.html">BxDatabaseStatement</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#a3a3d17bedaea092e10de99c4394f4f1e">prepare:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a newly allocated <a class="el" href="interface_bx_database_statement.html" title="Database prepared statement that may be executed multiple times.">BxDatabaseStatement</a> using the SQL provided.  <a href="#a3a3d17bedaea092e10de99c4394f4f1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_bx_database_statement.html">BxDatabaseStatement</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#a45254350677aa0cea5c3c200f6696883">prepareWith:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a newly allocated <a class="el" href="interface_bx_database_statement.html" title="Database prepared statement that may be executed multiple times.">BxDatabaseStatement</a> using the SQL and bind values provided.  <a href="#a45254350677aa0cea5c3c200f6696883"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_database_connection.html#ad111a3442d822210a6be044a1a9cf41a">rollbackTransaction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancels an existing database transaction.  <a href="#ad111a3442d822210a6be044a1a9cf41a"></a><br/></td></tr>
<tr><td colspan="2"><h2>Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_bx_database_connection.html#aa3a8090d407fdd2c6fce3d90b8e61d47">isLocking</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BxDatabaseConnectionType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_bx_database_connection.html#abaf5c488cf0acd9568e27844f2f31d74">connectionType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NSString *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_bx_database_connection.html#aaf70794a0676d42f9055c7ba91db0476">lastError</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NSRecursiveLock *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_bx_database_connection.html#a6a7d8d4a3acaf5bcc35d1a113f2b7bd9">recursiveLock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_bx_database_connection.html#a9fb33497a1d97faca5b35205f9bb1ffb">rawConnection</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Connects to and communicates with a database. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Bombaxtic LLC - <a href="http://www.bombaxtic.com">http://www.bombaxtic.com</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0</dd></dl>
<p><a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> opens a connection with a DBMS and provides methods for executing SQL queries, creating prepared statements, and controlling transactions. <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> uses <a class="el" href="interface_bx_database_statement.html" title="Database prepared statement that may be executed multiple times.">BxDatabaseStatement</a> instances for most of its interoperation with the DBMS such as executeWith:. Currently, <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> supports Oracle, MySQL, PostgreSQL, and SQLite.</p>
<p><a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> supports thread-safe access if the <code>locking</code> parameter is <code>YES</code> when the database is initialized. No state is shared between <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> instances and multiple concurrent connections to different databases are possible.</p>
<p>Example of connecting to a MySQL DBMS on localhost and using a prepared statement: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">@interface </span>MyHandler : <a class="code" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> {
    <a class="code" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> *_db;
 }
 <span class="keyword">@end</span>
 
 <span class="keyword">@implementation </span>MyHandler
 - (id)setup {
     _db = [[<a class="code" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> alloc] initWithMySQLServer:@&quot;localhost&quot;
                                                    database:@&quot;exampledb&quot;
                                                        user:@&quot;jane&quot;
                                                    password:@&quot;secret&quot;
                                                     locking:YES
                                                       error:nil];
     [_db execute:@&quot;CREATE TABLE ipInfo (rowId INT AUTO_INCREMENT, ip VARCHAR(64), key VARCHAR(64), value VARCHAR(128), PRIMARY KEY (rowId))&quot;];
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
 
 - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSString *ipAddress = [transport.serverVars objectForKey:@&quot;REMOTE_ADDR&quot;];
     NSMutableDictionary *results = [_db fetchNamedRowWith:@&quot;SELECT * FROM ipInfo WHERE ip=?&quot;, ipAddress, nil];
     <span class="keywordflow">if</span> (results != nil) {
         [transport <a class="code" href="interface_bx_transport.html#ad37d502b2dc0f1e4c5ed3c001c10d263" title="Writes the given NSString to the response stream.">write</a>:@&quot;Old variables:\n&quot;];
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;%@&quot;, results];
     }
     <a class="code" href="interface_bx_database_statement.html" title="Database prepared statement that may be executed multiple times.">BxDatabaseStatement</a> *stmt = [_db prepare:@&quot;INSERT INTO ipInfo (ip, key, value) VALUES (?, ?, ?)&quot;];
     <span class="keywordflow">for</span> (NSString *key in transport.<a class="code" href="interface_bx_transport.html#aa67473d64df2d85d33383e893be8374e">serverVars</a>) {
         [stmt <a class="code" href="interface_bx_database_statement.html#af44a46bd68dee6f195d0664bd058d74a" title="Binds the nil-terminated list of values to the prepared statement&amp;#39;s parameters...">bindWith</a>:ipAddress, key, [transport.serverVars objectForKey:key]];
         [stmt <a class="code" href="interface_bx_database_statement.html#a489fb62d1c9eb4214ad1bd220cf0bf78" title="Executes the prepared statement with whatever binds are in place.">execute</a>];
     }
     results = [_db fetchNamedRowWith:@&quot;SELECT * FROM ipInfo WHERE ip=?&quot;, ipAddress, nil];
     <span class="keywordflow">if</span> (results != nil) {
        [transport <a class="code" href="interface_bx_transport.html#ad37d502b2dc0f1e4c5ed3c001c10d263" title="Writes the given NSString to the response stream.">write</a>:@&quot;New variables:\n&quot;];
        [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;%@&quot;, results];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd>For more information, please see the documentation for the respective DBMS you are using </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aaf52b3d6472872841651409abf7e7dda"></a><!-- doxytag: member="BxDatabaseConnection::beginTransaction" ref="aaf52b3d6472872841651409abf7e7dda" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) beginTransaction </td>
          <td></td>
          <td class="paramname"></td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins a database transaction. </p>
<p><a class="anchor" id="beginTransaction"></a> Begins a new database transaction. Note that the database and tables must support transactions for this command to have any effect (e.g. MySQL MyISAM tables do not support transactions while InnoDB tables do). Currently, named transactions are not supported.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because transaction state is shared within a connection, transactions within a multithreaded connection may want to manually lock the <code>recursiveLock</code>.</dd>
<dd>
When using MySQL, calling <code>beginTransaction</code> implicitly calls <code>commitTransaction</code> </dd></dl>
<p>Example of using a transaction: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     [_db beginTransaction];
     NSArray *result = [_db fetchRowWith:@&quot;SELECT balance FROM accounts WHERE accountNumber=?&quot;, _accountNumber];
     BOOL cancel = NO;
     <span class="keywordflow">if</span> (result != nil) {
         <span class="keywordtype">double</span> balance = [[result lastObject] doubleValue];
         balance += 100;
         <span class="keywordflow">if</span> (! [_db executeWith:<span class="stringliteral">@&quot;UPDATE accounts SET balance=? WHERE accountNumber=?&quot;</span>, [NSString stringWithFormat:<span class="stringliteral">@&quot;%f&quot;</span>, balance], _accountNumber, nil]) {
             cancel = YES;
         }
     } <span class="keywordflow">else</span> {
         cancel = YES;
     }
     <span class="keywordflow">if</span> (cancel) {
         [_db rollbackTransaction];
         [transport <a class="code" href="interface_bx_transport.html#ad37d502b2dc0f1e4c5ed3c001c10d263" title="Writes the given NSString to the response stream.">write</a>:@&quot;Transaction cancelled&quot;];
     } <span class="keywordflow">else</span> {
         [_db commitTransaction];
         [transport <a class="code" href="interface_bx_transport.html#ad37d502b2dc0f1e4c5ed3c001c10d263" title="Writes the given NSString to the response stream.">write</a>:@&quot;Transaction succeeded&quot;];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd><code>YES</code> if the command succeeded, else <code>lastError</code> is set </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1388401ae0c42963f74e07baa9ab43f7"></a><!-- doxytag: member="BxDatabaseConnection::close" ref="a1388401ae0c42963f74e07baa9ab43f7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) close </td>
          <td></td>
          <td class="paramname"></td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the database connection. </p>
<p><a class="anchor" id="close"></a> This method permanently closes the database connection and frees up associated memory. After <code>close</code> is called, all other <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> methods no longer have any effect. As <code>close</code> is automatically called when the instance is deallocated, it is rarely necessary to call this method explicitly.</p>
<p>Example of explicitly closing a connection in a garbage-collected environment: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     <span class="keywordflow">if</span> ([[transport.<a class="code" href="interface_bx_transport.html#acb6405f5dc177297f02d1a867ee02288">queryVars</a> objectForKey:<span class="stringliteral">@&quot;command&quot;</span>] isEqual:<span class="stringliteral">@&quot;close&quot;</span>]) {
         [_db close];
         _db = nil;
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd><code>NO</code> if any errors were encountered</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a346e964e3aa16d346b293ecfb9758349"></a><!-- doxytag: member="BxDatabaseConnection::commitTransaction" ref="a346e964e3aa16d346b293ecfb9758349" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) commitTransaction </td>
          <td></td>
          <td class="paramname"></td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commits an existing database transaction. </p>
<p><a class="anchor" id="commitTransaction"></a> Note that the database and tables must support transactions for this command to have any effect (e.g. MySQL MyISAM tables do not support transactions while InnoDB tables do). Currently, named transactions are not supported.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because transaction state is shared within a connection, transactions within a multithreaded connection may want to manually lock the <code>recursiveLock</code>.</dd></dl>
<p>Example of using a transaction: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     [_db beginTransaction];
     NSArray *result = [_db fetchRowWith:@&quot;SELECT balance FROM accounts WHERE accountNumber=?&quot;, _accountNumber];
     BOOL cancel = NO;
     <span class="keywordflow">if</span> (result != nil) {
         <span class="keywordtype">double</span> balance = [[result lastObject] doubleValue];
         balance += 100;
         <span class="keywordflow">if</span> (! [_db executeWith:<span class="stringliteral">@&quot;UPDATE accounts SET balance=? WHERE accountNumber=?&quot;</span>, [NSString stringWithFormat:<span class="stringliteral">@&quot;%f&quot;</span>, balance], _accountNumber, nil]) {
             cancel = YES;
         }
     } <span class="keywordflow">else</span> {
         cancel = YES;
     }
     <span class="keywordflow">if</span> (cancel) {
         [_db rollbackTransaction];
         [transport <a class="code" href="interface_bx_transport.html#ad37d502b2dc0f1e4c5ed3c001c10d263" title="Writes the given NSString to the response stream.">write</a>:@&quot;Transaction cancelled&quot;];
     } <span class="keywordflow">else</span> {
         [_db commitTransaction];
         [transport <a class="code" href="interface_bx_transport.html#ad37d502b2dc0f1e4c5ed3c001c10d263" title="Writes the given NSString to the response stream.">write</a>:@&quot;Transaction succeeded&quot;];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd><code>YES</code> if the command succeeded, else <code>lastError</code> is set </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4d69e6d8dfa362c31cbc5a42c8f1be74"></a><!-- doxytag: member="BxDatabaseConnection::execute:" ref="a4d69e6d8dfa362c31cbc5a42c8f1be74" args="(NSString *sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) execute: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>sql</em></td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes the provided SQL. </p>
<p><a class="anchor" id="execute"></a> This command executes the raw SQL passed as the <code>sql</code> parameter. It is not advisable to construct the SQL from user-provided parameters due to the danger of SQL injection. In such cases, use of <code>executeWith:</code> is recommended.</p>
<p>Example of creating a database with <code>execute:</code> </p>
<div class="fragment"><pre class="fragment"> - (id)setup {
     _db = [[<a class="code" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> alloc] initWithSqliteMemoryLocking:YES error:nil];
     [_db execute:@&quot;CREATE TABLE cheeses (name TEXT, flavor INT)&quot;];
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sql</em>&nbsp;</td><td>the raw SQL to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>YES</code> if the command succeeded, else <code>lastError</code> is set </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa6eef02d9c33c3ef79b71e4fa477cedb"></a><!-- doxytag: member="BxDatabaseConnection::executeWith:" ref="aa6eef02d9c33c3ef79b71e4fa477cedb" args="(NSString *sql,[,]...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) executeWith: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>sql</em></td>
        </tr>
        <tr>
          <td class="paramkey">,</td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes the provided SQL with the provided values. </p>
<p><a class="anchor" id="executeWith"></a> This command executes the raw SQL passed as the <code>sql</code> parameter. The <code>NSStrings</code> following <code>sql</code> are bound to the placeholders in the SQL. The exact format for specifying the placeholders varies from database to database (e.g. <code></code>:name for Oracle, <code></code>? for MySQL, etc).</p>
<p>Example of inserting a value using <code>excuteWith:</code> </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSString *cheese = [transport.queryVars objectForKey:@&quot;cheese&quot;];
     NSString *flavor = [transport.queryVars objectForKey:@&quot;flavor&quot;];
     <span class="keywordflow">if</span> (cheese &amp;&amp; flavor) {
         [_db executeWith:@&quot;INSERT INTO cheeses (name, flavor) VALUES (:1, :2)&quot;, cheese, flavor, nil];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sql</em>&nbsp;</td><td>the raw SQL to execute, followed by a <code>nil</code> terminated list of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>YES</code> if the command succeeded, else <code>lastError</code> is set </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a94a1a9843080a3f7ebc9246faf0efd10"></a><!-- doxytag: member="BxDatabaseConnection::fetchAll:" ref="a94a1a9843080a3f7ebc9246faf0efd10" args="(NSString *sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) fetchAll: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>sql</em></td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an array of row arrays for a SELECT statement. </p>
<p><a class="anchor" id="fetchAll"></a> This command executes the raw SQL passed as the <code>sql</code> parameter and returns the result set as a <code>NSArray</code> populated with a <code>NSArray</code> rows. It is not advisable to construct the SQL from user-provided parameters due to the danger of SQL injection. In such cases, use of <code>fetchAllWith:</code> is recommended.</p>
<p>Note: NULL values are returned as [NSNull null]. All other values are NSStrings.</p>
<p>Example of returning all the results in a table: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSArray *results = [_db fetchAll:@&quot;SELECT name, flavor IN cheeses&quot;];
     <span class="keywordflow">if</span> (results) {
         <span class="keywordflow">for</span> (NSArray *result in results) {
             [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Name:%@ Flavor:%@\n&quot;, [result objectAtIndex:0], [result objectAtIndex:1]];
         }
     } <span class="keywordflow">else</span> {
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Error: %@&quot;, _db.lastError];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sql</em>&nbsp;</td><td>the raw SQL SELECT statement to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an populated array of rows or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ab9602263d3bb8d1d4086aae886f415f0"></a><!-- doxytag: member="BxDatabaseConnection::fetchAllWith:" ref="ab9602263d3bb8d1d4086aae886f415f0" args="(NSString *sql,[,]...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) fetchAllWith: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>sql</em></td>
        </tr>
        <tr>
          <td class="paramkey">,</td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an array of row arrays for a SELECT statement with the provided values. </p>
<p><a class="anchor" id="fetchAllWith"></a> This command executes the raw SQL passed as the <code>sql</code> parameter and returns the result set as a <code>NSArray</code> populated with a <code>NSArray</code> rows. The <code>NSStrings</code> following <code>sql</code> are bound to the placeholders in the SQL. The exact format for specifying the placeholders varies from database to database (e.g. <code></code>:name for Oracle, <code></code>? for MySQL, etc).</p>
<p>Note: NULL values are returned as [NSNull null]. All other values are NSStrings.</p>
<p>Example of returning all the results in a table: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSArray *results = [_db fetchAllWith:@&quot;SELECT name, flavor IN cheeses WHERE flavor &gt; ?&quot;, @&quot;5&quot;, nil];
     <span class="keywordflow">if</span> (results) {
         <span class="keywordflow">for</span> (NSArray *result in results) {
             [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Name:%@ Flavor:%@\n&quot;, [result objectAtIndex:0], [result objectAtIndex:1]];
         }
     } <span class="keywordflow">else</span> {
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Error: %@&quot;, _db.lastError];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sql</em>&nbsp;</td><td>the raw SQL SELECT statement to execute, followed by a <code>nil</code> terminated list of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an populated array of rows or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad14105b6c66984fc921e7e0e91091445"></a><!-- doxytag: member="BxDatabaseConnection::fetchNamedAll:" ref="ad14105b6c66984fc921e7e0e91091445" args="(NSString *sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) fetchNamedAll: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>sql</em></td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an array of row dictionaries for a SELECT statement. </p>
<p><a class="anchor" id="fetchNamedAll"></a> This command executes the raw SQL passed as the <code>sql</code> parameter and returns the result set as a <code>NSArray</code> populated with a <code>NSDictionary</code> rows. It is not advisable to construct the SQL from user-provided parameters due to the danger of SQL injection. In such cases, use of <code>fetchNamedAllWith:</code> is recommended.</p>
<p>Note: NULL values are returned as [NSNull null]. All other values are NSStrings.</p>
<p>Example of returning all the results in a table: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSArray *results = [_db fetchNamedAll:@&quot;SELECT name, flavor IN cheeses&quot;];
     <span class="keywordflow">if</span> (results) {
         <span class="keywordflow">for</span> (NSDictionary *result in results) {
             [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Name:%@ Flavor:%@\n&quot;,
                                   [result objectForKey:@&quot;name&quot;],
                                   [result objectForKey:@&quot;flavor&quot;]];
         }
     } <span class="keywordflow">else</span> {
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Error: %@&quot;, _db.lastError];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sql</em>&nbsp;</td><td>the raw SQL SELECT statement to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an populated array of rows or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a16b51c5cb344618db822617093741c4c"></a><!-- doxytag: member="BxDatabaseConnection::fetchNamedAllWith:" ref="a16b51c5cb344618db822617093741c4c" args="(NSString *sql,[,]...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) fetchNamedAllWith: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>sql</em></td>
        </tr>
        <tr>
          <td class="paramkey">,</td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an array of row dictionaries for a SELECT statement with the provided values. </p>
<p><a class="anchor" id="fetchNamedAllWith"></a> This command executes the raw SQL passed as the <code>sql</code> parameter and returns the result set as a <code>NSArray</code> populated with a <code>NSDictionary</code> rows. The <code>NSStrings</code> following <code>sql</code> are bound to the placeholders in the SQL. The exact format for specifying the placeholders varies from database to database (e.g. <code></code>:name for Oracle, <code></code>? for MySQL, etc).</p>
<p>Note: NULL values are returned as [NSNull null]. All other values are NSStrings.</p>
<p>Example of returning all the results in a table: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSArray *results = [_db fetchNamedAllWith:@&quot;SELECT name, flavor IN cheeses WHERE flavor &gt; ?&quot;, @&quot;5&quot;, nil];
     <span class="keywordflow">if</span> (results) {
         <span class="keywordflow">for</span> (NSDictionary *result in results) {
             [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Name:%@ Flavor:%@\n&quot;,
                                    [result objectForKey:@&quot;name&quot;],
                                    [result objectForKey:@&quot;flavor&quot;]];
         }
     } <span class="keywordflow">else</span> {
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Error: %@&quot;, _db.lastError];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sql</em>&nbsp;</td><td>the raw SQL SELECT statement to execute, followed by a <code>nil</code> terminated list of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an populated array of rows or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa3302ac78f09ea09a51cda69e4815fb4"></a><!-- doxytag: member="BxDatabaseConnection::fetchNamedRow:" ref="aa3302ac78f09ea09a51cda69e4815fb4" args="(NSString *sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSDictionary *) fetchNamedRow: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>sql</em></td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a single of row dictionary for a SELECT statement. </p>
<p><a class="anchor" id="fetchNamedRow"></a> This command executes the raw SQL passed as the <code>sql</code> parameter and returns the result set as a single <code>NSDictionary</code> row. It is not advisable to construct the SQL from user-provided parameters due to the danger of SQL injection. In such cases, use of <code>fetchNamedRowWith:</code> is recommended.</p>
<p>Note: NULL values are returned as [NSNull null]. All other values are NSStrings.</p>
<p>Example of returning a single results for a table: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSDictionary *result = [_db fetchNamedRow:@&quot;SELECT value, setOn IN settings WHERE name=&#39;config_path&#39;&quot;];
     <span class="keywordflow">if</span> (result) {
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Path:%@  set on:@%&quot;,
                                [result objectForKey:@&quot;value&quot;],
                                [result objectForKey:@&quot;setOn&quot;]];
     } <span class="keywordflow">else</span> {
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Error: %@&quot;, _db.lastError];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sql</em>&nbsp;</td><td>the raw SQL SELECT statement to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a single row dictionary or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a84ffce45f9f416453bd14e0f09f3e43c"></a><!-- doxytag: member="BxDatabaseConnection::fetchNamedRowWith:" ref="a84ffce45f9f416453bd14e0f09f3e43c" args="(NSString *sql,[,]...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSDictionary *) fetchNamedRowWith: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>sql</em></td>
        </tr>
        <tr>
          <td class="paramkey">,</td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a single of row dictionary for a SELECT statement with the provided values. </p>
<p><a class="anchor" id="fetchNamedRowWith"></a> This command executes the raw SQL passed as the <code>sql</code> parameter and returns the result set as a single <code>NSDictionary</code> row. The <code>NSStrings</code> following <code>sql</code> are bound to the placeholders in the SQL. The exact format for specifying the placeholders varies from database to database (e.g. <code></code>:name for Oracle, <code></code>? for MySQL, etc).</p>
<p>Note: NULL values are returned as [NSNull null]. All other values are NSStrings.</p>
<p>Example of returning a single results for a table: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSDictionary *results = [_db fetchNamedRowWith:@&quot;SELECT value, setOn IN settings WHERE name=?&quot;, @&quot;config_path&quot;, nil];
     <span class="keywordflow">if</span> (result) {
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Path:%@  set on:@%&quot;,
                                [result objectForKey:@&quot;value&quot;],
                                [result objectForKey:@&quot;setOn&quot;]];
     } <span class="keywordflow">else</span> {
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Error: %@&quot;, _db.lastError];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sql</em>&nbsp;</td><td>the raw SQL SELECT statement to execute, followed by a <code>nil</code> terminated list of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a single row dictionary or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aee6c7a159f66e0df2991c1ee7ce20843"></a><!-- doxytag: member="BxDatabaseConnection::fetchRow:" ref="aee6c7a159f66e0df2991c1ee7ce20843" args="(NSString *sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) fetchRow: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>sql</em></td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a single of row array for a SELECT statement. </p>
<p><a class="anchor" id="fetchRow"></a> This command executes the raw SQL passed as the <code>sql</code> parameter and returns the result set as a single <code>NSArray</code> row. It is not advisable to construct the SQL from user-provided parameters due to the danger of SQL injection. In such cases, use of <code>fetchRowWith:</code> is recommended.</p>
<p>Note: NULL values are returned as [NSNull null]. All other values are NSStrings.</p>
<p>Example of returning a single results for a table: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSArray *result = [_db fetchRow:@&quot;SELECT value, setOn IN settings WHERE name=&#39;config_path&#39;&quot;];
     <span class="keywordflow">if</span> (result) {
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Path:%@  set on:@%&quot;,
                               [result objectAtIndex:0],
                               [result objectAtIndex:1]];
     } <span class="keywordflow">else</span> {
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Error: %@&quot;, _db.lastError];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sql</em>&nbsp;</td><td>the raw SQL SELECT statement to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a single row array or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a3a9136ffa1139c6ad6eff9d72416389a"></a><!-- doxytag: member="BxDatabaseConnection::fetchRowWith:" ref="a3a9136ffa1139c6ad6eff9d72416389a" args="(NSString *sql,[,]...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) fetchRowWith: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>sql</em></td>
        </tr>
        <tr>
          <td class="paramkey">,</td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a single of row array for a SELECT statement with the provided values. </p>
<p><a class="anchor" id="fetchRowWith"></a> This command executes the raw SQL passed as the <code>sql</code> parameter and returns the result set as a single <code>NSArray</code> row. The <code>NSStrings</code> following <code>sql</code> are bound to the placeholders in the SQL. The exact format for specifying the placeholders varies from database to database (e.g. <code></code>:name for Oracle, <code></code>? for MySQL, etc).</p>
<p>Note: NULL values are returned as [NSNull null]. All other values are NSStrings.</p>
<p>Example of returning a single results for a table: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSArray *result = [_db fetchRowWith:@&quot;SELECT value, setOn IN settings WHERE name=?&quot;, @&quot;config_path&quot;, nil];
     <span class="keywordflow">if</span> (result) {
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Path:%@  set on:@%&quot;,
                                [result objectAtIndex:0],
                                [result objectAtIndex:1]];
     } <span class="keywordflow">else</span> {
         [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;Error: %@&quot;, _db.lastError];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sql</em>&nbsp;</td><td>the raw SQL SELECT statement to execute, followed by a <code>nil</code> terminated list of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a single row array or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1d9141ac450a15a4a9ed464b959c3bb8"></a><!-- doxytag: member="BxDatabaseConnection::initWithMySQLServer:database:user:password:locking:error:" ref="a1d9141ac450a15a4a9ed464b959c3bb8" args="(NSString *server,[database] NSString *database,[user] NSString *user,[password] NSString *password,[locking] BOOL locking,[error] NSString **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithMySQLServer: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>server</em></td>
        </tr>
        <tr>
          <td class="paramkey">database:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>database</em></td>
        </tr>
        <tr>
          <td class="paramkey">user:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>user</em></td>
        </tr>
        <tr>
          <td class="paramkey">password:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>password</em></td>
        </tr>
        <tr>
          <td class="paramkey">locking:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>locking</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSString **)&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> for a MySQL server. </p>
<p><a class="anchor" id="initWithMySQLServer"></a> This establishes a connection with a MySQL server. The MySQL server may be remote or local.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the threadsafe version of the MySQL client library is used</dd></dl>
<p>Establishing a connection to a remote MySQL database: </p>
<div class="fragment"><pre class="fragment"> - (id)setup {
     NSString *error = nil;
     _db = [[<a class="code" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> alloc] initWithMySQLServer:@&quot;10.20.30.69&quot;
                                                    database:@&quot;maindb&quot;
                                                        user:@&quot;jane&quot;
                                                    password:@&quot;secret&quot;
                                                     locking:YES
                                                       error:&amp;error]
     <span class="keywordflow">if</span> (error) {
         NSLog(<span class="stringliteral">@&quot;%@&quot;</span>, error);
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>This command is equivalent to calling: <div class="fragment"><pre class="fragment">   [bxDatabaseConnection initWithMySQLServer:server
                                    database:database
                                        user:user
                                    password:password
                                        port:0
                                      socket:nil
                                     locking:locking
                                       error:error];
</pre></div></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>See full initWithMySQL method for parameter details</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>server</em>&nbsp;</td><td>the location of the server such as 'localhost' or '192.168.1.100' </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>database</em>&nbsp;</td><td>the name of the database </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user</em>&nbsp;</td><td>the database user to connect as </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>password</em>&nbsp;</td><td>the password for the database user </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locking</em>&nbsp;</td><td>if <code>YES</code> then all database access will be guarded through the <code>recursiveLock</code> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>if not <code>nil</code> will be populated with the error message if an error occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a successfully connection <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ae7a2b46cc77af4f7c0c89a9050bd159f"></a><!-- doxytag: member="BxDatabaseConnection::initWithMySQLServer:database:user:password:port:socket:locking:error:" ref="ae7a2b46cc77af4f7c0c89a9050bd159f" args="(NSString *server,[database] NSString *database,[user] NSString *user,[password] NSString *password,[port] int port,[socket] NSString *socket,[locking] BOOL locking,[error] NSString **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithMySQLServer: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>server</em></td>
        </tr>
        <tr>
          <td class="paramkey">database:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>database</em></td>
        </tr>
        <tr>
          <td class="paramkey">user:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>user</em></td>
        </tr>
        <tr>
          <td class="paramkey">password:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>password</em></td>
        </tr>
        <tr>
          <td class="paramkey">port:</td>
          <td></td>
          <td class="paramtype">(int)&nbsp;</td>
          <td class="paramname"> <em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">socket:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>socket</em></td>
        </tr>
        <tr>
          <td class="paramkey">locking:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>locking</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSString **)&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> for a MySQL server. </p>
<p><a class="anchor" id="initWithMySQLServer2"></a> This establishes a connection with a MySQL server. The MySQL server may be remote or local.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the threadsafe version of the MySQL client library is used</dd></dl>
<p>Establishing a connection to a local MySQL database: </p>
<div class="fragment"><pre class="fragment"> - (id)setup {
     NSString *error = nil;
     _db = [[<a class="code" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> alloc] initWithMySQLServer:@&quot;localhost&quot;
                                                    database:@&quot;maindb&quot;
                                                        user:@&quot;joe&quot;
                                                    password:@&quot;secret&quot;
                                                        port:0
                                                      socket:nil
                                                     locking:YES
                                                       error:&amp;error]
     <span class="keywordflow">if</span> (error) {
         NSLog(<span class="stringliteral">@&quot;%@&quot;</span>, error);
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>server</em>&nbsp;</td><td>the location of the server such as 'localhost' or '192.168.1.100' </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>database</em>&nbsp;</td><td>the name of the database </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user</em>&nbsp;</td><td>the database user to connect as </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>password</em>&nbsp;</td><td>the password for the database user </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>the port of the server. 0 will use the default port of 3306 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>socket</em>&nbsp;</td><td>the local mysql socket to connect to such as '/tmp/mysql.sock'. nil uses the default </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locking</em>&nbsp;</td><td>if <code>YES</code> then all database access will be guarded through the <code>recursiveLock</code> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>if not <code>nil</code> will be populated with the error message if an error occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>See <code>mysql_real_connect</code> in the MySQL Reference Manual for more information</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a successfully connection <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="af22026065b4005c973d2a4f5c0f9ab3b"></a><!-- doxytag: member="BxDatabaseConnection::initWithOracleInstance:user:password:locking:error:" ref="af22026065b4005c973d2a4f5c0f9ab3b" args="(NSString *instance,[user] NSString *user,[password] NSString *password,[locking] BOOL locking,[error] NSString **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithOracleInstance: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>instance</em></td>
        </tr>
        <tr>
          <td class="paramkey">user:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>user</em></td>
        </tr>
        <tr>
          <td class="paramkey">password:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>password</em></td>
        </tr>
        <tr>
          <td class="paramkey">locking:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>locking</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSString **)&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> to an Oracle server. </p>
<p><a class="anchor" id="initWithMyOracleInstance"></a> This establishes a connection with database instance on an Oracle server.</p>
<p>Establishing a connection to a remote Oracle database: </p>
<div class="fragment"><pre class="fragment"> - (id)setup {
     NSString *error = nil;
     _db = [[<a class="code" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> alloc] initWithMyOracleInstance:@&quot;//oradb.intranet:1521/ORCL&quot;
                                                             user:@&quot;scott&quot;
                                                         password:@&quot;tiger&quot;
                                                          locking:YES
                                                            error:&amp;error]
     <span class="keywordflow">if</span> (error) {
         NSLog(<span class="stringliteral">@&quot;%@&quot;</span>, error);
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instance</em>&nbsp;</td><td>the Oracle connection string as for SQLPLUS or nil for default local connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user</em>&nbsp;</td><td>the database user to connect as </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>password</em>&nbsp;</td><td>the password for the database user </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locking</em>&nbsp;</td><td>if <code>YES</code> then all database access will be guarded through the <code>recursiveLock</code> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>if not <code>nil</code> will be populated with the error message if an error occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>See the OCIServerAttach function in the OCI Programmer's Guide for more information on valid <code>instance</code> values.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a successfully connection <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="af979486a5816070db16c1697706414b3"></a><!-- doxytag: member="BxDatabaseConnection::initWithPostgreSQLServer:database:user:password:port:locking:error:" ref="af979486a5816070db16c1697706414b3" args="(NSString *server,[database] NSString *database,[user] NSString *user,[password] NSString *password,[port] NSString *port,[locking] BOOL locking,[error] NSString **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithPostgreSQLServer: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>server</em></td>
        </tr>
        <tr>
          <td class="paramkey">database:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>database</em></td>
        </tr>
        <tr>
          <td class="paramkey">user:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>user</em></td>
        </tr>
        <tr>
          <td class="paramkey">password:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>password</em></td>
        </tr>
        <tr>
          <td class="paramkey">port:</td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>port</em></td>
        </tr>
        <tr>
          <td class="paramkey">locking:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>locking</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSString **)&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> for a PostgreSQL server. </p>
<p><a class="anchor" id="initWithPostgreSQLServer"></a> This establishes a connection with a PostgreSQL server. The PostgreSQL server may be remote or local.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The enabling of <code>locking</code> is recommended.</dd></dl>
<p>Example of connecting to a local PostgreSQL server: </p>
<div class="fragment"><pre class="fragment"> - (id)setup {
     NSString *error = nil
     _db = [[<a class="code" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> alloc] initWithPostgreSQLServer:@&quot;localhost&quot;
                                                         database:@&quot;maindb&quot;
                                                             user:@&quot;joe&quot;
                                                         password:@&quot;secret&quot;
                                                             port:0
                                                          locking:YES
                                                            error:&amp;error]
     <span class="keywordflow">if</span> (error) {
         NSLog(<span class="stringliteral">@&quot;%@&quot;</span>, error);
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>server</em>&nbsp;</td><td>the location of the server such as 'localhost' or '192.168.1.100' </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>database</em>&nbsp;</td><td>the name of the database </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user</em>&nbsp;</td><td>the database user to connect as </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>password</em>&nbsp;</td><td>the password for the database user </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>the port of the server. 0 will use the default port of 3306 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locking</em>&nbsp;</td><td>if <code>YES</code> (recommended) then all database access will be guarded through the <code>recursiveLock</code> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>if not <code>nil</code> will be populated with the error message if an error occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>See <code>PQsetdbLogin</code> in the PostgreSQL <code>libpq</code> documentation for more information</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a successfully connection <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1092698d2ba1929ce99f3bfa2f69248e"></a><!-- doxytag: member="BxDatabaseConnection::initWithSQLiteFile:locking:error:" ref="a1092698d2ba1929ce99f3bfa2f69248e" args="(NSString *path,[locking] BOOL locking,[error] NSString **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithSQLiteFile: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
        </tr>
        <tr>
          <td class="paramkey">locking:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>locking</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSString **)&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> for a SQLite file. </p>
<p><a class="anchor" id="initWithSQLiteFile"></a> This establishes connection for a SQLite file. The the file does not already exist, it will be created.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The file format expected is SQLite 3</dd></dl>
<p>Example of connecting to a SQLite file located at /path/to/file.sqlite3: </p>
<div class="fragment"><pre class="fragment"> - (id)setup {
     NSString *error = nil
     _db = [[<a class="code" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> alloc] initWithSQLiteFile:@&quot;/path/to/file.sqlite3&quot;
                                                    locking:NO
                                                      error:&amp;error]
     <span class="keywordflow">if</span> (error) {
         NSLog(<span class="stringliteral">@&quot;%@&quot;</span>, error);
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>the location of the SQLite file to open or create. Use ':memory:' for an in-memory database </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locking</em>&nbsp;</td><td>if <code>YES</code> (recommended) then all database access will be guarded through the <code>recursiveLock</code> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>if not <code>nil</code> will be populated with the error message if an error occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>See <code>sqlite3_open</code> in the SQLite C Interface documentation for more information</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a successfully connection <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9b91b0183da97c3ce5d303af22996c6b"></a><!-- doxytag: member="BxDatabaseConnection::initWithSQLiteMemoryWithLocking:error:" ref="a9b91b0183da97c3ce5d303af22996c6b" args="(BOOL locking,[error] NSString **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithSQLiteMemoryWithLocking: </td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>locking</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSString **)&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> for an in-memory SQLite database. </p>
<p><a class="anchor" id="initWithSQLiteMemoryWithLocking"></a> This connection creates an in-memory SQLite database that will not be saved when the <a class="el" href="interface_bx_app.html" title="Routes client requests to BxHandler instances.">BxApp</a> closes</p>
<p>Example of connecting to a new in-memory SQLite database: </p>
<div class="fragment"><pre class="fragment"> - (id)setup {
     NSString *error = nil
     _db = [[<a class="code" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> alloc] initWithSQLiteMemoryWithLocking:NO
                                                                   error:&amp;error]
     <span class="keywordflow">if</span> (error) {
         NSLog(<span class="stringliteral">@&quot;%@&quot;</span>, error);
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>This is equivalent to calling: <div class="fragment"><pre class="fragment">  [bxDatabaseConnection initWithSQLiteFile:@&quot;:memory:&quot;
                                   locking:locking
                                     error:error];
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>locking</em>&nbsp;</td><td>if <code>YES</code> (recommended) then all database access will be guarded through the <code>recursiveLock</code> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>if not <code>nil</code> will be populated with the error message if an error occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>See <code>sqlite3_open</code> in the SQLite C Interface documentation for more information</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a successfully connection <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> or <code>nil</code> if an error occurred </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a3a3d17bedaea092e10de99c4394f4f1e"></a><!-- doxytag: member="BxDatabaseConnection::prepare:" ref="a3a3d17bedaea092e10de99c4394f4f1e" args="(NSString *sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_bx_database_statement.html">BxDatabaseStatement</a> *) prepare: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>sql</em></td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a newly allocated <a class="el" href="interface_bx_database_statement.html" title="Database prepared statement that may be executed multiple times.">BxDatabaseStatement</a> using the SQL provided. </p>
<p><a class="anchor" id="prepare"></a> This command executes the raw SQL passed as the <code>sql</code> parameter and returns a prepared statement that may be executed many times efficiently.</p>
<p>Values may be bound to prepared statements using bind indicators which vary from database to database. For example, MySQL uses '?' in place of the variable, Oracle uses ':name', PostgreSQL '$1', and SQLite can use any of the above. For details, please consult your database's documentation on bind values in prepared statements.</p>
<p>Example of preparing and executing a <a class="el" href="interface_bx_database_statement.html" title="Database prepared statement that may be executed multiple times.">BxDatabaseStatement</a>: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSString *count = [transport.queryVars objectForKey:@&quot;count&quot;];
     <span class="keywordflow">if</span> (count) {
         <a class="code" href="interface_bx_database_statement.html" title="Database prepared statement that may be executed multiple times.">BxDatabaseStatement</a> *stmt = [_db prepare:@&quot;INSERT INTO counter (number) VALUES (?)&quot;];
         <span class="keywordflow">if</span> (stmt == nil) {
             NSLog(<span class="stringliteral">@&quot;%@&quot;</span>, _db.lastError);
         } <span class="keywordflow">else</span> {
             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; [count integerValue]; i++) {
                 [stmt <a class="code" href="interface_bx_database_statement.html#ae2f75862f418523e7f3555c9c3e9efa0" title="Binds a value to a 1-indexed column in the prepared statement&amp;#39;s parameters.">bindValue</a>:[NSString stringWithFormat:@&quot;%d&quot;, i]
                       <a class="code" href="interface_bx_database_statement.html#ae2f75862f418523e7f3555c9c3e9efa0" title="Binds a value to a 1-indexed column in the prepared statement&amp;#39;s parameters.">forColumn</a>:i + 1];
                 [stmt <a class="code" href="interface_bx_database_statement.html#a489fb62d1c9eb4214ad1bd220cf0bf78" title="Executes the prepared statement with whatever binds are in place.">execute</a>];
             }
         }
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sql</em>&nbsp;</td><td>the SQL to be executed when the prepared statement is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>BxDatabaseStatement's <code>initWithConnection:</code> method</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an autoreleased <a class="el" href="interface_bx_database_statement.html" title="Database prepared statement that may be executed multiple times.">BxDatabaseStatement</a> or <code>nil</code> if an error occurred, in which case <code>lastError</code> is set </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a45254350677aa0cea5c3c200f6696883"></a><!-- doxytag: member="BxDatabaseConnection::prepareWith:" ref="a45254350677aa0cea5c3c200f6696883" args="(NSString *sql,[,]...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_bx_database_statement.html">BxDatabaseStatement</a> *) prepareWith: </td>
          <td></td>
          <td class="paramtype">(NSString *)&nbsp;</td>
          <td class="paramname"> <em>sql</em></td>
        </tr>
        <tr>
          <td class="paramkey">,</td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a newly allocated <a class="el" href="interface_bx_database_statement.html" title="Database prepared statement that may be executed multiple times.">BxDatabaseStatement</a> using the SQL and bind values provided. </p>
<p><a class="anchor" id="prepareWith"></a> This command executes the raw SQL passed as the <code>sql</code> parameter and returns a prepared statement that may be executed many times efficiently. Initially the statement is bound using the <code>nil</code> terminated arguments passed after <code>sql</code>.</p>
<p>Values may be bound to prepared statements using bind indicators which vary from database to database. For example, MySQL uses '?' in place of the variable, Oracle uses ':name', PostgreSQL '$1', and SQLite can use any of the above. For details, please consult your database's documentation on bind values in prepared statements.</p>
<p>Example of preparing and executing a <a class="el" href="interface_bx_database_statement.html" title="Database prepared statement that may be executed multiple times.">BxDatabaseStatement</a>: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSString *count = [transport.queryVars objectForKey:@&quot;count&quot;];
     <span class="keywordflow">if</span> (count) {
         <a class="code" href="interface_bx_database_statement.html" title="Database prepared statement that may be executed multiple times.">BxDatabaseStatement</a> *stmt = [_db prepareWith:@&quot;INSERT INTO counter (number) VALUES (?)&quot;, @&quot;0&quot;, nil];
         <span class="keywordflow">if</span> (stmt == nil) {
             NSLog(<span class="stringliteral">@&quot;%@&quot;</span>, _db.lastError);
         } <span class="keywordflow">else</span> {
             [stmt <a class="code" href="interface_bx_database_statement.html#a489fb62d1c9eb4214ad1bd220cf0bf78" title="Executes the prepared statement with whatever binds are in place.">execute</a>];
             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; [count integerValue]; i++) {
                 [stmt <a class="code" href="interface_bx_database_statement.html#ae2f75862f418523e7f3555c9c3e9efa0" title="Binds a value to a 1-indexed column in the prepared statement&amp;#39;s parameters.">bindValue</a>:[NSString stringWithFormat:@&quot;%d&quot;, i]
                                                  <a class="code" href="interface_bx_database_statement.html#ae2f75862f418523e7f3555c9c3e9efa0" title="Binds a value to a 1-indexed column in the prepared statement&amp;#39;s parameters.">forColumn</a>:i + 1];
                 [stmt <a class="code" href="interface_bx_database_statement.html#a489fb62d1c9eb4214ad1bd220cf0bf78" title="Executes the prepared statement with whatever binds are in place.">execute</a>];
             }
         }
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sql</em>&nbsp;</td><td>the SQL to be executed when the prepared statement is called followed by all bind variables and <code>nil</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>BxDatabaseStatement's <code>initWithConnection:</code> method</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an autoreleased <a class="el" href="interface_bx_database_statement.html" title="Database prepared statement that may be executed multiple times.">BxDatabaseStatement</a> or <code>nil</code> if an error occurred, in which case <code>lastError</code> is set </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad111a3442d822210a6be044a1a9cf41a"></a><!-- doxytag: member="BxDatabaseConnection::rollbackTransaction" ref="ad111a3442d822210a6be044a1a9cf41a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) rollbackTransaction </td>
          <td></td>
          <td class="paramname"></td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancels an existing database transaction. </p>
<p><a class="anchor" id="rollbackTransaction"></a> Note that the database and tables must support transactions for this command to have any effect (e.g. MySQL MyISAM tables do not support transactions while InnoDB tables do). Currently, named transactions are not supported.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because transaction state is shared within a connection, transactions within a multithreaded connection may want to manually lock the <code>recursiveLock</code>.</dd></dl>
<p>Example of using a transaction: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     [_db beginTransaction];
     NSArray *result = [_db fetchRowWith:@&quot;SELECT balance FROM accounts WHERE accountNumber=?&quot;, _accountNumber];
     BOOL cancel = NO;
     <span class="keywordflow">if</span> (result != nil) {
         <span class="keywordtype">double</span> balance = [[result lastObject] doubleValue];
         balance += 100;
         <span class="keywordflow">if</span> (! [_db executeWith:<span class="stringliteral">@&quot;UPDATE accounts SET balance=? WHERE accountNumber=?&quot;</span>, [NSString stringWithFormat:<span class="stringliteral">@&quot;%f&quot;</span>, balance], _accountNumber, nil]) {
             cancel = YES;
         }
     } <span class="keywordflow">else</span> {
         cancel = YES;
     }
     <span class="keywordflow">if</span> (cancel) {
         [_db rollbackTransaction];
         [transport <a class="code" href="interface_bx_transport.html#ad37d502b2dc0f1e4c5ed3c001c10d263" title="Writes the given NSString to the response stream.">write</a>:@&quot;Transaction cancelled&quot;];
     } <span class="keywordflow">else</span> {
         [_db commitTransaction];
         [transport <a class="code" href="interface_bx_transport.html#ad37d502b2dc0f1e4c5ed3c001c10d263" title="Writes the given NSString to the response stream.">write</a>:@&quot;Transaction succeeded&quot;];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd><code>YES</code> if the command succeeded, else <code>lastError</code> is set </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="abaf5c488cf0acd9568e27844f2f31d74"></a><!-- doxytag: member="BxDatabaseConnection::connectionType" ref="abaf5c488cf0acd9568e27844f2f31d74" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BxDatabaseConnectionType) connectionType<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="connectionType"></a> The type of database this <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a> is connected to.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The result may be: <div class="fragment"><pre class="fragment">    BxDatabaseConnectionTypeUnknown -&gt; Undefined
    BxDatabaseConnectionTypeMySQL -&gt; MySQL
    BxDatabaseConnectionTypeOracle -&gt; Oracle
    BxDatabaseConnectionTypePostgreSQL -&gt; PostgreSQL
    BxDatabaseConnectionTypeSQLite -&gt; SQLite (in memory or file based)
</pre></div></dd></dl>
<p>Example of checking the type of database: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSArray *result;
     <span class="keywordflow">if</span> (_db.connectionType == BxDatabaseConnectionTypeMySQL) {
         result = [_db fetchRowWith:@&quot;SELECT * FROM cheese WHERE name=?&quot;, @&quot;cheddar&quot;, nil];
     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_db.connectionType == BxDatabaseConnectionTypePostgreSQL) {
         result = [_db fetchRowWith:@&quot;SELECT * FROM cheese WHERE name=$1&quot;, @&quot;cheddar&quot;, nil];
     }
     <span class="comment">// ...</span>
     <span class="keywordflow">return</span> <span class="keyword">self</span>
 }
</pre></div><dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa3a8090d407fdd2c6fce3d90b8e61d47"></a><!-- doxytag: member="BxDatabaseConnection::isLocking" ref="aa3a8090d407fdd2c6fce3d90b8e61d47" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isLocking<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="isLocking"></a> Is set to <code>YES</code> if the connection was established with locking enabled</p>
<p>Example of checking if locking is enabled for improved transactions: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     <span class="keywordflow">if</span> (_db.isLocking) {
         [_db.recursiveLock lock];
         [_db beginTransaction];
     }
     <span class="comment">// ...</span>
     <span class="keywordflow">if</span> (_db.isLocking) {
         [_db commitTransaction];
         [_db.recursiveLock unlock];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div> <dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aaf70794a0676d42f9055c7ba91db0476"></a><!-- doxytag: member="BxDatabaseConnection::lastError" ref="aaf70794a0676d42f9055c7ba91db0476" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) lastError<code> [read, write, copy]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="lastError"></a> If an error has occurred in a BxPreparedStatement or <a class="el" href="interface_bx_database_connection.html" title="Connects to and communicates with a database.">BxDatabaseConnection</a>, the text of the error will be available in /c lastError.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>In a multithreaded <a class="el" href="interface_bx_app.html" title="Routes client requests to BxHandler instances.">BxApp</a> it is possible for an additional error to occur between the time the first error occurs and <code>lastError</code> is checked. If this rare case is a concern, you may manually lock <code>recursiveLock</code> to prevent it.</dd></dl>
<p>Example of checking the error: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
    <span class="keywordflow">if</span> (! [_db.execute:<span class="stringliteral">@&quot;SELECT * FROM invalidTable&quot;</span>]) {
        [transport <a class="code" href="interface_bx_transport.html#ad37d502b2dc0f1e4c5ed3c001c10d263" title="Writes the given NSString to the response stream.">write</a>:db.lastError];
    }
    <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9fb33497a1d97faca5b35205f9bb1ffb"></a><!-- doxytag: member="BxDatabaseConnection::rawConnection" ref="a9fb33497a1d97faca5b35205f9bb1ffb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void*) rawConnection<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="rawConnection"></a> This is the raw database connection object backing the connection. Use of this object is not recommended and is not protected by the <code>recursiveLock</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The type of object returned varies as follows: <div class="fragment"><pre class="fragment">     MySQL -&gt; MYSQL *
     Oracle -&gt; OCISvcCtx *
     PostgreSQL -&gt; PGconn *
     SQLite -&gt; sqlite3 *
</pre></div></dd></dl>
<p>Example of accessing the raw connection of a SQLite database: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     sqlite3 *rawDb = (sqlite3 *) _db.rawConnection;
     BOOL isAutocommitMode = sqlite3_get_autocommit(rawDb) != 0;
     <span class="comment">// ...</span>
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6a7d8d4a3acaf5bcc35d1a113f2b7bd9"></a><!-- doxytag: member="BxDatabaseConnection::recursiveLock" ref="a6a7d8d4a3acaf5bcc35d1a113f2b7bd9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSRecursiveLock*) recursiveLock<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="recursiveLock"></a> The raw <code>NSRecursiveLock</code> if locking enabled. Normally there is no need to access this directly, but occasionally, such as with transactions, it may be useful.</p>
<p>Example of checking if locking is enabled for improved transactions: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     <span class="keywordflow">if</span> (_db.isLocking) {
         [_db.recursiveLock lock];
         [_db beginTransaction];
     }
     <span class="comment">// ...</span>
     <span class="keywordflow">if</span> (_db.isLocking) {
         [_db commitTransaction];
         [_db.recursiveLock unlock];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div> <dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</body>
</html>
