<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Bombaxtic Framework: BxHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>BxHandler Class Reference</h1><!-- doxytag: class="BxHandler" -->
<p>Persistent handler for client requests.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for BxHandler:</div>
<div class="dynsection">
 <div class="center">
  <img src="interface_bx_handler.png" usemap="#BxHandler_map" alt=""/>
  <map id="BxHandler_map" name="BxHandler_map">
<area href="interface_bx_static_file_handler.html" alt="BxStaticFileHandler" shape="rect" coords="0,56,123,80"/>
</map>
 </div>
</div>

<p><a href="class_bx_handler-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_handler.html#acd9859cab718fe2046b1aa8e9a2904ed">renderWithTransport:</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processes the request and sends the output via <code>transport</code>.  <a href="#acd9859cab718fe2046b1aa8e9a2904ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_bx_handler.html#a132112355457ba16b8ee60ce458bcd14">setup</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares the <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> prior to renderWithTransport calls.  <a href="#a132112355457ba16b8ee60ce458bcd14"></a><br/></td></tr>
<tr><td colspan="2"><h2>Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_bx_app.html">BxApp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_bx_handler.html#a8be3e001e9685c3f157b74a046cc45ee">app</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NSMutableDictionary *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_bx_handler.html#ad32f15c3cb37380e27f60b47d39077cb">state</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Persistent handler for client requests. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Bombaxtic LLC - <a href="http://www.bombaxtic.com">http://www.bombaxtic.com</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0</dd></dl>
<p>The central functionality of every Bombax web application is provided by customized <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> subclasses. <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> is either subclassed explicitly as an Objective-C or implicitly as a BXML file to handle incoming client requests.</p>
<p>Unlike the <a class="el" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> instance, a <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> is normally retained for as long as the application is run. However, note that the <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> is not created until a client requests it (see <a class="el" href="interface_bx_app.html" title="Routes client requests to BxHandler instances.">BxApp</a> for more information). Only one <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> instance is used for the <a class="el" href="interface_bx_app.html" title="Routes client requests to BxHandler instances.">BxApp</a>, even if it is used for multiple paths (e.g. as the default handler and for a particular prefix).</p>
<p><a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> has only two basic methods for overriding, setup and renderWithTransport. renderWithTransport is the most important of these two as it is called with each client request in order to create the output and often is the only method that needs to be overridden.</p>
<p>Basic example of overriding a <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> to create a custom request handler: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">@interface </span>MyHandler : <a class="code" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> {
     <span class="keywordtype">int</span> _counter;
 }
 - (id)renderHeader:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport;
 - (id)renderFooter:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport;
 <span class="keyword">@end</span>
 
 <span class="keyword">@implementation </span>MyHandler
 - (id)<a class="code" href="interface_bx_handler.html#a132112355457ba16b8ee60ce458bcd14" title="Prepares the BxHandler prior to renderWithTransport calls.">setup</a> {
     _counter = 0;
 }
 
 - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     _counter += 1;
     [<span class="keyword">self</span> renderHeader:transport];
     [transport <a class="code" href="interface_bx_transport.html#a791c6984cedbbf72bb115e510aeea68d" title="Writes the given format string to the response stream.">writeFormat</a>:@&quot;There have been %d visits.&quot;, _counter];
     [<span class="keyword">self</span> renderFooter:transport];
 }
 
 - (id)renderHeader:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     [transport <a class="code" href="interface_bx_transport.html#ad37d502b2dc0f1e4c5ed3c001c10d263" title="Writes the given NSString to the response stream.">write</a>:@&quot;&lt;html&gt;&lt;body&gt;&quot;];
 }

 - (id)renderFooter:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     [transport <a class="code" href="interface_bx_transport.html#ad37d502b2dc0f1e4c5ed3c001c10d263" title="Writes the given NSString to the response stream.">write</a>:@&quot;&lt;/body&gt;&lt;/html&gt;&quot;];
 }
 <span class="keyword">@end</span>
</pre></div><p>Similar example using a BXML and the <a class="el" href="interface_bx_transport.html#state">state</a> property: </p>
<div class="fragment"><pre class="fragment"> &lt;?<a class="code" href="interface_bx_handler.html#a132112355457ba16b8ee60ce458bcd14" title="Prepares the BxHandler prior to renderWithTransport calls.">setup</a>
  [<span class="keyword">self</span>.state setObject:[NSNumber numberWithInteger:0] forKey:<span class="stringliteral">@&quot;counter&quot;</span>];
 ?&gt;
 &lt;html&gt;
  &lt;body&gt;
   &lt;?
   <span class="keywordtype">int</span> counter = [[<span class="keyword">self</span>.state objectForKey:<span class="stringliteral">@&quot;counter&quot;</span>] integerValue] + 1;
   [_ writeFormat:<span class="stringliteral">@&quot;There have been %d visits.&quot;</span>, counter];
   [<span class="keyword">self</span>.state setObject:[NSNumber numberWithInteger:counter] forKey:<span class="stringliteral">@&quot;counter&quot;</span>];
   ?&gt;
  &lt;/body&gt;
 &lt;/html&gt;
</pre></div><p>An example which uses a backing class with BXML: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">@interface </span>BackingHandler : <a class="code" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> {
     <span class="keywordtype">int</span> _counter;
 }
 @property (nonatomic, assign) int counter;
 @end
 
 @implementation BackingHandler
 @synthesize counter = _counter;
 - (<span class="keywordtype">id</span>)<a class="code" href="interface_bx_handler.html#a132112355457ba16b8ee60ce458bcd14" title="Prepares the BxHandler prior to renderWithTransport calls.">setup</a> {
     _counter = 0;
 }
 <span class="keyword">@end</span>
</pre></div> <div class="fragment"><pre class="fragment"> &lt;?base BackingHandler ?&gt;
 &lt;html&gt;
  &lt;body&gt;
   There have been &lt;? <span class="keyword">self</span>.counter++; [_ writeFormat:<span class="stringliteral">@&quot;%d&quot;</span>, <span class="keyword">self</span>.counter] ?&gt; visits.
  &lt;/body&gt;
 &lt;/html&gt;
</pre></div><dl class="warning"><dt><b>Warning:</b></dt><dd>The previous examples non-atomically alter the handler state. Because state is shared between renderWithTransport calls, if your <a class="el" href="interface_bx_app.html" title="Routes client requests to BxHandler instances.">BxApp</a> is running as a multithreaded application (which is the default) this could allow for a counter increment to be clobbered. One strategy for addressing this is to use a NSLock (see Apple's Thread Programming Guide for more information): <div class="fragment"><pre class="fragment"> <span class="keyword">static</span> NSLock *_myLock;
 - (id)<a class="code" href="interface_bx_handler.html#a132112355457ba16b8ee60ce458bcd14" title="Prepares the BxHandler prior to renderWithTransport calls.">setup</a> {
     _myLock = [[NSLock init] alloc];
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
 - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     <span class="keywordflow">@try</span> {
         [_myLock lock];
         <span class="comment">// ... perform synchronized operation</span>
     } <span class="keywordflow">@finally</span> {
         [_myLock unlock];
     }
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>For more information about using <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> and the Bombaxtic request lifecycle, please see the "Bombax Developer's Guide" </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acd9859cab718fe2046b1aa8e9a2904ed"></a><!-- doxytag: member="BxHandler::renderWithTransport:" ref="acd9859cab718fe2046b1aa8e9a2904ed" args="(BxTransport *transport)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) renderWithTransport: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_bx_transport.html">BxTransport</a> *)&nbsp;</td>
          <td class="paramname"> <em>transport</em></td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Processes the request and sends the output via <code>transport</code>. </p>
<p><a class="anchor" id="renderWithTransport"></a> This is the method responsible for handling an individual client request. Using the <a class="el" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> instance, the output stream (via the writeXXX methods) and a variety of parameters are accessible. renderWithTransport is only called once for each client request.</p>
<p>The basic mechanism of handling a request is by subclassing <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> and overriding the renderWithTransport method. By default, renderWithTransport is empty.</p>
<p>BXML '&lt;? ?&gt;' sections are automatically inserted into a generated renderWithTransport method in the order provided, connected by the non-code sections. For example, </p>
<div class="fragment"><pre class="fragment"> &lt;p&gt;This &lt;? [_ write:<span class="stringliteral">@&quot;is&quot;</span>] ?&gt; a &lt;? [_ write:<span class="stringliteral">@&quot;BxApp&quot;</span>] ?&gt;.&lt;/p&gt;
</pre></div><p> will output '&lt;p&gt;This is a <a class="el" href="interface_bx_app.html" title="Routes client requests to BxHandler instances.">BxApp</a>.&lt;/p&gt;'.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The <code>transport</code> parameter is created and released for a single client request and is not intended to be retained.</dd></dl>
<p>Example of basic output using renderWithTransport: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     [transport setHeader:<span class="stringliteral">@&quot;Content-Type&quot;</span> value:<span class="stringliteral">@&quot;text/plain&quot;</span>];
     [transport writeFormat:<span class="stringliteral">@&quot;The current time is %@.&quot;</span>, [NSDate date]];
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><p>Similar example using BXML: </p>
<div class="fragment"><pre class="fragment"> &lt;? [_ setHeader:<span class="stringliteral">@&quot;Content-Type&quot;</span> value:<span class="stringliteral">@&quot;text/plain&quot;</span>] ?&gt;
 The current time is &lt;? [_ write:[[NSDate date] description]] ?&gt;.
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>transport</em>&nbsp;</td><td>a newly created <a class="el" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> instance connected to the client </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> instance </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a132112355457ba16b8ee60ce458bcd14"></a><!-- doxytag: member="BxHandler::setup" ref="a132112355457ba16b8ee60ce458bcd14" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) setup </td>
          <td></td>
          <td class="paramname"></td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares the <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> prior to renderWithTransport calls. </p>
<p><a class="anchor" id="setup"></a> This method is called <b>once</b> in the lifetime of the <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a>, directly after initialization by <a class="el" href="interface_bx_app.html" title="Routes client requests to BxHandler instances.">BxApp</a>. setup is usually used to create any state needed over the successive renderWithTransport calls, including opening database or file connections.</p>
<p>To add setup code to BXML, use the special '&lt;?setup ?&gt;' section. This may be repeated if necessary and does not strictly need to be at the beginning of the file, though this is recommended.</p>
<p>Example of setting up state through setup: </p>
<div class="fragment"><pre class="fragment"> - (id)<a class="code" href="interface_bx_handler.html#a132112355457ba16b8ee60ce458bcd14" title="Prepares the BxHandler prior to renderWithTransport calls.">setup</a> {
     NSMutableDictionary *lastVisits = [NSMutableDictionary dictionaryWithCapacity:8];
     [<span class="keyword">self</span>.state setObject:lastVisits forKey:<span class="stringliteral">@&quot;lastVisits&quot;</span>];
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
 
 - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     NSMutableDictionary *lastVisits = [<span class="keyword">self</span>.state objectForKey:<span class="stringliteral">@&quot;lastVisits&quot;</span>];
     NSString *ipAddress = [<span class="keyword">self</span>.serverVars objectForKey:<span class="stringliteral">@&quot;REMOTE_ADDR&quot;</span>];
     NSDate *date = [lastVisits objectForKey:ipAddress];
     <span class="keywordflow">if</span> (date == nil) {
         [transport write:<span class="stringliteral">@&quot;This is your first visit.&quot;</span>];    
     } <span class="keywordflow">else</span> {
         [transport writeFormat:<span class="stringliteral">@&quot;Your last visit was on %@.&quot;</span>, date];
     }
     [lastVisits setObject:[NSDate date] forKey:ipAddress];
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div><p>Example of creating state in BXML: </p>
<div class="fragment"><pre class="fragment"> &lt;?<a class="code" href="interface_bx_handler.html#a132112355457ba16b8ee60ce458bcd14" title="Prepares the BxHandler prior to renderWithTransport calls.">setup</a>
  [<span class="keyword">self</span>.state setObject:[NSDate date] forKey:<span class="stringliteral">@&quot;initDate&quot;</span>];
 ?&gt;
 &lt;html&gt;
  &lt;body&gt;
   This handler was initialized on &lt;? [transport write:[[<span class="keyword">self</span>.state objectForKey:<span class="stringliteral">@&quot;initDate&quot;</span>] description]] ?&gt;.
  &lt;/body&gt;
 &lt;/html&gt;
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> instance </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="a8be3e001e9685c3f157b74a046cc45ee"></a><!-- doxytag: member="BxHandler::app" ref="a8be3e001e9685c3f157b74a046cc45ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_bx_app.html">BxApp</a>*) app<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="app"></a> This is a reference to the global <a class="el" href="interface_bx_app.html" title="Routes client requests to BxHandler instances.">BxApp</a>. The two main uses of this property are to access the global (i.e. pan-Bxhandler) state and to dynamically rewrite path handling.</p>
<p>Example of accessing the <a class="el" href="interface_bx_app.html" title="Routes client requests to BxHandler instances.">BxApp</a> state: </p>
<div class="fragment"><pre class="fragment"> - (id)renderWithTransport:(<a class="code" href="interface_bx_transport.html" title="Handles communication with HTTP client.">BxTransport</a> *)transport {
     <span class="keywordtype">int</span> visits = [[<span class="keyword">self</span>.app.state objectForKey:<span class="stringliteral">@&quot;visits&quot;</span>] integerValue];
     visits++;
     [transport writeFormat:<span class="stringliteral">@&quot;You are visitor %d.&quot;</span>, visits];
     [<span class="keyword">self</span>.app.state setObject:[NSNumber numberWithInteger:visits] forKey:<span class="stringliteral">@&quot;visits&quot;</span>];
     <span class="keywordflow">return</span> <span class="keyword">self</span>;
 }
</pre></div> <dl class="warning"><dt><b>Warning:</b></dt><dd>Because the <a class="el" href="interface_bx_app.html" title="Routes client requests to BxHandler instances.">BxApp</a> is shared between handlers, thread-safe programming techniques such as using NSLock may be necessary in your application. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad32f15c3cb37380e27f60b47d39077cb"></a><!-- doxytag: member="BxHandler::state" ref="ad32f15c3cb37380e27f60b47d39077cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSMutableDictionary*) state<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="state"></a> This is main container of state for the <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> between client connections. It may be used in place of or in addition to subclass instance variables. For BXML handlers that are not based on a <a class="el" href="interface_bx_handler.html" title="Persistent handler for client requests.">BxHandler</a> subclass, it is the main way to keep persistent state.</p>
<p>Example of using state to enable or disable a handler by looking for 'disable' or 'enable' as a query variable: </p>
<div class="fragment"><pre class="fragment"> &lt;?<a class="code" href="interface_bx_handler.html#a132112355457ba16b8ee60ce458bcd14" title="Prepares the BxHandler prior to renderWithTransport calls.">setup</a> [<span class="keyword">self</span>.state setObject:[NSNumber numberWithBool:YES] forKey:<span class="stringliteral">@&quot;isEnabled&quot;</span>]; ?&gt;
 &lt;html&gt;
  &lt;body&gt;
   &lt;?
    <span class="keywordflow">if</span> ([_.queryVars objectForKey:<span class="stringliteral">@&quot;disable&quot;</span>] != nil) {
        [<span class="keyword">self</span>.state setObject:[NSNumber numberWithBool:NO] forKey:<span class="stringliteral">@&quot;isEnabled&quot;</span>];
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([_.queryVars objectForKey:<span class="stringliteral">@&quot;enable&quot;</span>] != nil) {
        [<span class="keyword">self</span>.state setObject:[NSNumber numberWithBool:YES] forKey:<span class="stringliteral">@&quot;isEnabled&quot;</span>];
    }
   ?&gt;
   ...
   &lt;? <span class="keywordflow">if</span> ([[<span class="keyword">self</span>.<a class="code" href="interface_bx_handler.html#ad32f15c3cb37380e27f60b47d39077cb">state</a> objectForKey:<span class="stringliteral">@&quot;isEnabled&quot;</span>] boolValue] == YES) { ?&gt;
    This handler is enabled.
   &lt;? } <span class="keywordflow">else</span> { ?&gt;
    This handler is disabled.
   &lt;? } ?&gt;
  &lt;/body&gt;
 &lt;/html&gt;
</pre></div> <dl class="warning"><dt><b>Warning:</b></dt><dd>See discussion of using NSLock above for information using state in a thread-safe way. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</body>
</html>
